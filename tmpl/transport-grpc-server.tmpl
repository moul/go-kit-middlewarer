// Autogenerated code, do not change directly.
// To make changes to this file, please modify the templates at
// go-kit-middlewarer/tmpl/*.tmpl

package grpc

import(
	"golang.org/x/net/context"
        //"google.golang.org/grpc"

	ep "github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"

	{{.BasePackageImport}}
	"{{.EndpointPackage}}"
)

type toEndpoint func({{.BasePackageName}}.{{.InterfaceName}}) ep.Endpoint

// ServerLayer is a wrapper for {{.BasePackage}}.{{.InterfaceName}} which returns a
// github.com/go-kit/kit/endpoint.Middleware.  This allows you to specify
// Middleware while creating GRPC Servers.
type ServerLayer func( base {{.BasePackageName}}.{{.InterfaceName}}, path string ) ep.Middleware

func epID( ep ep.Endpoint ) ep.Endpoint {
	return ep
}

func serverFactory( {{.InterfaceNameLcase}} {{.BasePackageName}}.{{.InterfaceName}}, config ServerConfig, path string, endp toEndpoint, dec grpctransport.DecodeRequestFunc, enc grpctransport.EncodeResponseFunc) *grpctransport.Server {
	ctx := context.Background()
	var middlewares []ep.Middleware
	for _, w := range config.ServerLayers {
		middlewares = append( middlewares, w( {{.InterfaceNameLcase}}, path ))
	}

	middlewares = append( middlewares, config.Middlewares...)

	var options []grpctransport.ServerOption
	options = append(options, grpctransport.ServerBefore(config.RequestFuncs...))
	options = append(options, grpctransport.ServerAfter(config.ResponseFuncs...))
	options = append(options, config.Options...)

	server := grpctransport.NewServer(
		ctx,
		ep.Chain(epID, middlewares...)(endp({{.InterfaceNameLcase}})),
		dec,
		enc,
		options...
	)
	return server
}

// ServersForEndpoints will take the given arguments, associate all of
// the proper endpoints together, and register itself as a GRPC handler for
// {{.BasePackage}}.{{.InterfaceName}}.
func ServerForEndpoints( {{.InterfaceNameLcase}} {{.BasePackageName}}.{{.InterfaceName}}, wrappers ...ServerLayer )  (server {{.BasePackageName}}.{{.BasePackageNameCap}}Server) {
        return ServerForEndpointsWithConfig({{.InterfaceNameLcase}}, ServerConfig{ServerLayers: wrappers})
}

type grpcServer struct {
          {{range .Methods}}
          {{.MethodNameLcase}} grpctransport.Handler
          {{end}}
}

{{range .Methods}}
func (s *grpcServer) {{.MethodName}}(ctx context.Context, req *{{.BasePackageName}}.{{.MethodName}}Request) (*{{.BasePackageName}}.{{.MethodName}}Reply, error) {
        _, rep, err := s.{{.MethodNameLcase}}.ServeGRPC(ctx, req)
        if err != nil {
                return nil, err
        }
        return rep.(*{{.BasePackageName}}.{{.MethodName}}Reply), nil
}
{{end}}

// ServerForEndpointsWithConfig will take the given arguments, associate
// all of the endpoints together, and register itself as a GRPC handler for
// {{.BasePackage}}.{{.InterfaceName}}.
//
// The function uses the ServerConfig specification to be setup. Any properties
// can be specified within the ServerConfig structure.
func ServerForEndpointsWithConfig( {{.InterfaceNameLcase}} {{.BasePackageName}}.{{.InterfaceName}}, config ServerConfig) (server {{.BasePackageName}}.{{.BasePackageNameCap}}Server) {
	return &grpcServer{
		{{range .Methods}}
		{{.MethodNameLcase}}: serverFactory( {{.InterfaceNameLcase}}, config, {{.EndpointPackageName}}.Path{{.MethodName}}, make{{.MethodName}}Endpoint, decode{{.MethodName}}Request, encode{{.MethodName}}Response),{{end}}
	}
}

// ServerConfig represents a set of configuation options that can be passed
// and overwritten when instanciating the Handlers.  This allows for maximum
// configuration and cutomization.  If nothing is provided, then defaults will
// be used.
type ServerConfig struct {
	// Context represents the default Context to use.  Defaults to
	// context.Context.Background()
	Context context.Context

	// Options represents a list of potential
	// github.com/go-kit/kit/transport/grpc.ServerOption(s).  These options
	// allow for direct manipulation of the
	// github.com/go-kit/kit/transport/grpc.Server, if desired.
	// These Options will be applied after the supplied ErrorEncoder, if it is
	// provided.
	Options []grpctransport.ServerOption

	// ServerLayers represents a list of potential ServerLayers. Since a
	// ServerLayer generates an Endpoint, the provided ServerLayers will be
	// invoked as a chain of middlewares, in the order provided, to the
	// generated Endpoint.
	ServerLayers []ServerLayer

	// Middlewares represetns a list of potential
	// github.com/go-kit/kit/endpoint.Middleware(s). These Middlewares will be
	// applied after any supplied ServerLayers.
	Middlewares []ep.Middleware

	// RequestFuncs represents a list of potential
	// github.com/go-kit/kit/transport/grpc.RequestFunc(s) that will be invoked
	// before the processing of the Endpoint.
	RequestFuncs []grpctransport.RequestFunc

	// ResponseFuncs represents a list of potential
	// github.com/go-kit/kit/transport/grpc.ServerResponseFunc(s) that will be
	// invoked before the flush of the response generated by the Endpoint.
	ResponseFuncs []grpctransport.ResponseFunc
}

{{define "make-endpoint"}}
// make{{.MethodName}}Endpoint creates a github.com/go-kit/kit/endpoint.Endpoint for {{.BasePackage}}.{{.InterfaceName}}.{{.MethodName}}.
// It will automatically wrap and unwrap the arguments and results of the method.
func make{{.MethodName}}Endpoint({{.InterfaceNameLcase}} {{.BasePackageName}}.{{.InterfaceName}}) ep.Endpoint {
	return func({{.ContextParamName}} context.Context, request interface{}) (resp interface{}, {{.ErrorResultName}} error) {
		req := request.(*{{.BasePackageName}}.{{.MethodName}}Request)

		{{if .Results}}
		{{if .HasMoreThanOneResult}}
                resp = {{.InterfaceNameLcase}}.{{.MethodName}}(*req)
		{{else if .HasErrorResult}}
		resp, err = {{.InterfaceNameLcase}}.{{.MethodName}}(*req)
		{{else}}
		resp = {{.InterfaceNameLcase}}.{{.MethodName}}(*req)
		{{end}}
		{{else}}
		{{.InterfaceNameLcase}}.{{.MethodName}}({{.MethodArgumentNamesStr}})
		{{end}}

		return
	}
}
{{end}}
{{range .Methods}}{{template "make-endpoint" .}}{{end}}

{{define "request-response"}}
// decode{{.MethodName}}Request creates a decoder for {{.BasePackage}}.{{.InterfaceName}}.{{.MethodName}}
func decode{{.MethodName}}Request(_ context.Context, r interface{}) (interface{}, error) {
	req := r.(*{{.BasePackageName}}.{{.MethodName}}Request)
	return req, nil
}

// decode{{.MethodName}}Response creates a decoder for {{.BasePackage}}.{{.InterfaceName}}.{{.MethodName}}
func decode{{.MethodName}}Response(_ context.Context, r interface{}) (interface{}, error) {
	req := r.(*{{.BasePackageName}}.{{.MethodName}}Reply)
	return req, nil
}

// encode{{.MethodName}}Request creates an encoder for {{.BasePackage}}.{{.InterfaceName}}.{{.MethodName}}
func encode{{.MethodName}}Request (_ context.Context, r interface{}) (interface{}, error) {
        req := r.(*{{.BasePackageName}}.{{.MethodName}}Request)
	return req, nil
}

// encode{{.MethodName}}Response creates an encoder for {{.BasePackage}}.{{.InterfaceName}}.{{.MethodName}}
func encode{{.MethodName}}Response (_ context.Context, r interface{}) (interface{}, error) {
     resp := r.(*{{.BasePackageName}}.{{.MethodName}}Reply)
     return resp, nil
}

{{end}}
{{define "param"}}	{{if .IsContext}}{{else}}{{.PublicName}} {{.Type}} `json:"{{.Name}}" xml:"{{.Name}}"`{{end}}{{end}}
{{range .Methods}}{{template "request-response" .}}{{end}}
