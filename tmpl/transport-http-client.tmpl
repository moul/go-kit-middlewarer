// Autogenerated code, do not change directly.
// To make changes to this file, please modify the templates at
// go-kit-middlewarer/tmpl/*.tmpl

package http

import (
	"io"
	"net/http"
	"net/url"
	stdlibpath "path"
	"strings"

	{{range .ExtraImports}}
	{{.}}{{end}}

	kitendpoint "github.com/go-kit/kit/endpoint"
	httptransport "github.com/go-kit/kit/transport/http"
	kitsd "github.com/go-kit/kit/sd"

	"{{.EndpointPackage}}"
	{{.BasePackageImport}}
)

// ClientLayer is a function that takes an address and path string, so you
// can have extra information, then it should return a
// github.com/go-kit/kit/transport/http.ClientOption to wrap around the
// endpoint.
type ClientLayer func( addr, path string ) kitendpoint.Middleware

// clientFactory will take a path, encoding function, decoding function, and a
// slice of github.com/go-kit/kit/transport/http.ClientOption(s)
func clientFactory( path string, enc httptransport.EncodeRequestFunc, dec httptransport.DecodeResponseFunc, config ClientConfig ) kitsd.Factory {
	return func(addr string) (kitendpoint.Endpoint, io.Closer, error) {
		// first we need to ensure that the address given (addr) is valid.
		if !strings.HasPrefix(addr, "http") {
			addr = "http://" + addr
		}
		uri, err := url.Parse(addr)
		if err != nil {
			panic(err)
		}

		if config.PathPrefix != "" {
			path = stdlibpath.Join("/", config.PathPrefix, path)
		}
		
		p, err := url.Parse(path)
		if err != nil {
			panic(err)
		}

		uri = uri.ResolveReference(p)

		var options []httptransport.ClientOption
		if config.Client != nil {
			options = append(options, httptransport.SetClient(config.Client))
		}

		options = append(options, httptransport.BufferedStream(config.BufferedStream))
		options = append(options, httptransport.ClientBefore(config.RequestFuncs...))
		options = append(options, httptransport.ClientAfter(config.ClientResponseFuncs...))
		options = append(options, config.Options...)

		cli := httptransport.NewClient(
			config.Method, uri, enc, dec, options...
		)

		var middlewares []kitendpoint.Middleware
		for _, cl := range config.ClientLayers {
			middlewares = append(middlewares, cl(addr, path))
		}

		mw := kitendpoint.Chain(epID, middlewares...)
		mw = kitendpoint.Chain(mw, config.Middlewares...)

		ep := cli.Endpoint()
		return mw(ep), nil, nil
	}
}

// NewClient creates a new {{.InterfaceName}} that will call methods at
// the given address provided by the addr string.  This function takes a series
// of ClientLayer(s) that will be applied to the client before the
// subsequent method call.
func NewClient( addr string, {{range .ExtraInterfaces}}{{.Name}} {{.Type}}, {{end}}wrappers ...ClientLayer ) {{.BasePackageName}}.{{.InterfaceName}} {
	return NewClientWithConfig(addr,{{range .ExtraInterfaces}}{{.Name}}, {{end}}ClientConfig{ClientLayers: wrappers})
}

// NewClientWithOptions creates a new {{.InterfaceName}} that will call methods at
// the given address provided by the addr string.  This function takes a series
// of ClientLayer(s) that will be applied to the client before the
// subsequent method call.
func NewClientWithOptions( addr string, {{range .ExtraInterfaces}}{{.Name}} {{.Type}}, {{end}}wrappers []ClientLayer, options []httptransport.ClientOption ) {{.BasePackageName}}.{{.InterfaceName}} {
	return NewClientWithConfig(addr,{{range .ExtraInterfaces}}{{.Name}}, {{end}}ClientConfig{ClientLayers: wrappers, Options: options})	
}

// NewClientWithConfig creates a new {{.InterfaceName}} that will call methods
// at the given address provided by the addr string. This function takes a
// ClientConfig that specifies underlying options that will be applied to
// every Endpoint.
func NewClientWithConfig( addr string,{{range .ExtraInterfaces}}{{.Name}} {{.Type}}, {{end}}config ClientConfig) {{.BasePackageName}}.{{.InterfaceName}} {
	if config.Method == "" {
		config.Method = "GET"
	}

	var (
		{{range .Methods}}
		{{.MethodNameLcase}}Endpoint, _, _ = clientFactory( {{.EndpointPackageName}}.Path{{.MethodName}}, encode{{.MethodName}}Request, decode{{.MethodName}}Response, config)(addr){{end}}
	)

	return &client{{.InterfaceName}} {
		{{range .ExtraInterfaces}}{{.PublicName}}: {{.Name}},
		{{end}}
		{{range .Methods}}
		{{.MethodNameLcase}}Endpoint: {{.MethodNameLcase}}Endpoint,{{end}}
	}
}

// ClientConfig represents a set of various options that can be used to
// configure as many options as one would like for a Client. The fields here
// correspond to the fields and options contained within the Client from
// go-kit's http transport package.
//
// You only need to specify what you'd like to override.  In this case the
// zero values are all useful.
type ClientConfig struct {

	// Client represents a net/http.Client to use. If nil, this will end up
	// using net/http.DefaultClient
	Client *http.Client

	// Method specifies which request method to use. If empty, then this will
	// default to "GET"
	Method string

	// PathPrefix allows for you to specify an optional path prefix to use when
	// making the request.  This is useful for a custom Mux being used on the
	// server.
	//
	// Please note that the PathPrefix should be preceeded with a '/'. If one
	// is not set, one will be added.
	//
	// At the moment, parsing the path will panic on an error, so please ensure
	// that the PathPrefix is url-safe.
	PathPrefix string

	// ClientLayers represents a list of ClientLayers to apply to the Client.
	// ClientLayers can be useful, as they are Middlewares that have access to
	// the Service being invoked, as well as the address being dialed.
	//
	// The ClientLayers are applied before the Middlewares.
	ClientLayers []ClientLayer

	// Middlewares are a potential list of Middlewares to wrap the generated
	// endpoint.
	Middlewares []kitendpoint.Middleware

	// Options are a list of potential options to apply to the generated
	// github.com/go-kit/kit/transport/http.Client.
	//
	// Options are the last things to be applied, so they are capable of
	// overwriting the specified RequestFuncs, ClientResponseFuncs, and
	// BufferedStream ClientConfig Options.
	Options []httptransport.ClientOption

	// RequestFuncs represetns a list of potential RequestFunc(s) to be applied to
	// the Client. These will be applied to the Request before the Request
	// leaves.
	RequestFuncs []httptransport.RequestFunc

	// ClientResponseFuncs represents a list of potential ClientResponseFunc(s).
	// These Response Funcs are capable of touching the Response before being
	// returned to the Endpoint.
	ClientResponseFuncs []httptransport.ClientResponseFunc

	// BufferedStream allows for the specification of whether to automatically
	// close the Body of the Response or not.
	BufferedStream bool
}
